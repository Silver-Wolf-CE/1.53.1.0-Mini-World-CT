<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="45">
  <CheatEntries>
    <CheatEntry>
      <ID>1807637699</ID>
      <Description>"暴力Aimbot-Lua(玩家訊息表Aimbot範圍90格)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$Lua}
if syntaxcheck then return end

[ENABLE]
-- 初始化索引為0（從第一個敵人開始）
if _aim_index == nil then
  _aim_index = 0
end

-- 分開的Yaw和Pitch地址
local YAW_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+8"   -- Yaw角度地址
local PITCH_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+C"  -- Pitch角度地址

-- 距離配置（單位：遊戲單位）
local MIN_AIM_DISTANCE = 10   -- 最小瞄準距離
local MAX_AIM_DISTANCE = 9000  -- 最大瞄準距離

LeftsuperLuaAutoClickForTriggerbot_thread = createNativeThread(function (thread)
  thread.freeOnTerminate(false)
  thread.Name = 'Aimbot_thread'

  -- 緩存玩家信息，減少重複讀取
  local cachedSelfFaction = nil
  local cachedPlayerX, cachedPlayerY, cachedPlayerZ = nil, nil, nil
  local cachedEnemyCount = 0
  local cachedEnemyListBase = nil
  local lastCacheUpdate = 0

  while not thread.Terminated do
    -- 獲取敵人列表基址
    local basePtr = readInteger("libiworld.dll+169B900")

    if basePtr and basePtr ~= 0 then
      basePtr = readInteger(basePtr + 0x78)
      if basePtr and basePtr ~= 0 then
        -- 計算玩家數量：ret = (address1 - address2) // 4
        local address1 = readInteger(basePtr + 0x78) or 0
        local address2 = readInteger(basePtr + 0x74) or 0
        local enemyCount = 0

        if address1 &gt; address2 then
          enemyCount = math.floor((address1 - address2) / 4)
        end

        -- 檢查是否有有效敵人
        if enemyCount and enemyCount &gt; 0 then
          -- 定期更新緩存（每10ms）
          local currentTime = getTickCount()
          if currentTime - lastCacheUpdate &gt; 10 then
            -- 獲取玩家自身陣營（緩存）
            local SelfCampPtr = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+15C")
            if SelfCampPtr and SelfCampPtr ~= 0 then
              cachedSelfFaction = readInteger(SelfCampPtr + 0x24) or 0
            else
              cachedSelfFaction = 0
            end

            -- 獲取玩家自身位置（緩存）
            local playerBase = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+68")
            if playerBase then
              cachedPlayerX = readInteger(playerBase + 0x298, true) or 0
              cachedPlayerY = readInteger(playerBase + 0x29C, true) or 0
              cachedPlayerZ = readInteger(playerBase + 0x2A0, true) or 0
            end

            -- 緩存敵人列表基址和數量
            cachedEnemyListBase = address2
            cachedEnemyCount = enemyCount

            lastCacheUpdate = currentTime
          end

          -- 檢查緩存是否有效
          if cachedEnemyListBase and cachedEnemyListBase ~= 0 and
             cachedPlayerX and cachedPlayerY and cachedPlayerZ and
             cachedEnemyCount &gt; 0 then

            local foundValidEnemy = false
            local attempts = 0

            while not foundValidEnemy and attempts &lt; cachedEnemyCount and not thread.Terminated do
              -- 確保索引在有效範圍內
              if _aim_index &gt;= cachedEnemyCount then
                _aim_index = 0
              end

              -- 計算當前敵人地址
              local enemyTablePtr = readInteger(cachedEnemyListBase + _aim_index * 4)

              if enemyTablePtr and enemyTablePtr ~= 0 then
                -- 讀取血量
                local enemyHP = readFloat(enemyTablePtr + 0x10) or 100.0

                -- 檢查血量是否有效
                if enemyHP &gt; 0.0 then
                  -- 讀取陣營
                  local enemyFaction = readInteger(enemyTablePtr + 0x24) or 0

                  -- 陣營判斷
                  local shouldAim = false

                  if cachedSelfFaction == 0 then
                    shouldAim = true
                  elseif enemyFaction ~= cachedSelfFaction then
                    shouldAim = true
                  end

                  if shouldAim then
                    -- 讀取敵人位置
                    local enemyX = readInteger(enemyTablePtr + 0x14, true) or 0
                    local enemyY = readInteger(enemyTablePtr + 0x18, true) or 0
                    local enemyZ = readInteger(enemyTablePtr + 0x1C, true) or 0

                    -- 計算X和Z的距離（水平距離）
                    local dx = enemyX - cachedPlayerX
                    local dz = enemyZ - cachedPlayerZ
                    local horizontalDist2 = dx*dx + dz*dz

                    -- 計算實際距離（開方）
                    local actualDistance = math.sqrt(horizontalDist2)

                    -- 只用一個IF判斷距離是否在範圍內
                    if actualDistance &gt; MIN_AIM_DISTANCE and actualDistance &lt; MAX_AIM_DISTANCE then
                      -- 計算Yaw角度
                      local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
                      if aimYaw &lt; 0 then
                        aimYaw = aimYaw + 360.0
                      end
                      aimYaw = aimYaw % 360.0

                      -- 計算Pitch角度
                      local dy = enemyY - cachedPlayerY
                      local aimPitch = -math.atan2(dy, actualDistance) * (180.0 / math.pi)

                      -- 限制Pitch範圍
                      if aimPitch &lt; -88.0 then aimPitch = -88.0 end
                      if aimPitch &gt; 88.0 then aimPitch = 88.0 end

                      -- 寫入瞄準角度
                      writeFloat(YAW_ADDRESS, aimYaw)
                      writeFloat(PITCH_ADDRESS, aimPitch)

                      foundValidEnemy = true
                    end
                  end
                end
              end

              -- 切換到下一個目標
              _aim_index = _aim_index + 1
              attempts = attempts + 1
            end
          end
        end
      end
    end

    sleep(1)
  end
end)

[DISABLE]
if LeftsuperLuaAutoClickForTriggerbot_thread then
  LeftsuperLuaAutoClickForTriggerbot_thread.terminate()
  LeftsuperLuaAutoClickForTriggerbot_thread.waitfor()
  LeftsuperLuaAutoClickForTriggerbot_thread.destroy()
  LeftsuperLuaAutoClickForTriggerbot_thread = nil
  _aim_index = nil
end
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>1807637706</ID>
      <Description>"暴力Aimbot-Lua(玩家訊息表Aimbot範圍90格+FOV)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$Lua}
if syntaxcheck then return end

[ENABLE]
-- 初始化索引為0（從第一個敵人開始）
if _aim_index == nil then
  _aim_index = 0
end

-- 分開的Yaw和Pitch地址
local YAW_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+8"   -- Yaw角度地址
local PITCH_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+C"  -- Pitch角度地址
local FOV_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+B4"   -- FOV地址

-- 距離配置（單位：遊戲單位）
local MIN_AIM_DISTANCE = 10   -- 最小瞄準距離
local MAX_AIM_DISTANCE = 9000  -- 最大瞄準距離

-- FOV設定（可自定義）
if _custom_fov_limit == nil then
  _custom_fov_limit = 0.0  -- 0表示使用遊戲FOV，&gt;0表示自定義FOV限制
end

LeftsuperLuaAutoClickForTriggerbot_thread = createNativeThread(function (thread)
  thread.freeOnTerminate(false)
  thread.Name = 'Aimbot_thread'

  -- 緩存玩家資訊，減少重複讀取
  local cachedSelfFaction = nil
  local cachedPlayerX, cachedPlayerY, cachedPlayerZ = nil, nil, nil
  local cachedPlayerYaw = nil  -- 緩存玩家當前Yaw角度
  local cachedCurrentFOV = nil -- 緩存當前FOV
  local cachedEnemyCount = 0
  local cachedEnemyListBase = nil
  local lastCacheUpdate = 0

  -- 函數：計算兩個角度之間的最小差值
  local function angleDifference(angle1, angle2)
    local diff = math.abs(angle1 - angle2) % 360
    return math.min(diff, 360 - diff)
  end

  -- 函數：檢查目標是否在FOV內
  local function isTargetInFOV(targetYaw, playerYaw, fovValue)
    if not playerYaw or not fovValue then
      return true  -- 如果無法讀取玩家角度或FOV，則允許瞄準所有目標
    end

    -- 計算Yaw角度差
    local yawDiff = angleDifference(targetYaw, playerYaw)

    -- 檢查是否在FOV範圍內（FOV/2，因為FOV通常是指總視野角度）
    return yawDiff &lt;= (fovValue / 2)
  end

  -- 函數：獲取實際FOV限制
  local function getActualFOVLimit(gameFOV, customLimit)
    if customLimit &gt; 0 then
      return customLimit  -- 使用自定義FOV限制
    else
      return gameFOV      -- 使用遊戲FOV
    end
  end

  while not thread.Terminated do
    -- 獲取敵人列表基址
    local basePtr = readInteger("libiworld.dll+169B900")

    if basePtr and basePtr ~= 0 then
      basePtr = readInteger(basePtr + 0x78)
      if basePtr and basePtr ~= 0 then
        -- 計算玩家數量：ret = (address1 - address2) // 4
        local address1 = readInteger(basePtr + 0x78) or 0
        local address2 = readInteger(basePtr + 0x74) or 0
        local enemyCount = 0

        if address1 &gt; address2 then
          enemyCount = math.floor((address1 - address2) / 4)
        end

        -- 檢查是否有有效敵人
        if enemyCount and enemyCount &gt; 0 then
          -- 定期更新緩存（每10ms）
          local currentTime = getTickCount()
          if currentTime - lastCacheUpdate &gt; 10 then
            -- 獲取玩家自身陣營（緩存）
            local SelfCampPtr = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+15C")
            if SelfCampPtr and SelfCampPtr ~= 0 then
              cachedSelfFaction = readInteger(SelfCampPtr + 0x24) or 0
            else
              cachedSelfFaction = 0
            end

            -- 獲取玩家自身位置（緩存）
            local playerBase = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+68")
            if playerBase then
              cachedPlayerX = readInteger(playerBase + 0x298, true) or 0
              cachedPlayerY = readInteger(playerBase + 0x29C, true) or 0
              cachedPlayerZ = readInteger(playerBase + 0x2A0, true) or 0
            end

            -- 更新玩家當前Yaw角度
            cachedPlayerYaw = readFloat(YAW_ADDRESS) or 0.0

            -- 更新當前FOV
            cachedCurrentFOV = readFloat(FOV_ADDRESS) or 0.0

            -- 緩存敵人列表基址和數量
            cachedEnemyListBase = address2
            cachedEnemyCount = enemyCount

            lastCacheUpdate = currentTime
          end

          -- 檢查緩存是否有效
          if cachedEnemyListBase and cachedEnemyListBase ~= 0 and
             cachedPlayerX and cachedPlayerY and cachedPlayerZ and
             cachedEnemyCount &gt; 0 then

            -- 計算實際FOV限制
            local actualFOVLimit = 0.0
            if cachedCurrentFOV and cachedCurrentFOV &gt; 0 then
              actualFOVLimit = getActualFOVLimit(cachedCurrentFOV, _custom_fov_limit)
            else
              -- 如果讀取不到FOV，使用自定義限制或預設60度
              actualFOVLimit = _custom_fov_limit &gt; 0 and _custom_fov_limit or 60.0
            end

            local foundValidEnemy = false
            local attempts = 0

            while not foundValidEnemy and attempts &lt; cachedEnemyCount and not thread.Terminated do
              -- 確保索引在有效範圍內
              if _aim_index &gt;= cachedEnemyCount then
                _aim_index = 0
              end

              -- 計算當前敵人地址
              local enemyTablePtr = readInteger(cachedEnemyListBase + _aim_index * 4)

              if enemyTablePtr and enemyTablePtr ~= 0 then
                -- 讀取血量
                local enemyHP = readFloat(enemyTablePtr + 0x10) or 100.0

                -- 檢查血量是否有效
                if enemyHP &gt; 0.0 then
                  -- 讀取陣營
                  local enemyFaction = readInteger(enemyTablePtr + 0x24) or 0

                  -- 陣營判斷
                  local shouldAim = false

                  if cachedSelfFaction == 0 then
                    shouldAim = true
                  elseif enemyFaction ~= cachedSelfFaction then
                    shouldAim = true
                  end

                  if shouldAim then
                    -- 讀取敵人位置
                    local enemyX = readInteger(enemyTablePtr + 0x14, true) or 0
                    local enemyY = readInteger(enemyTablePtr + 0x18, true) or 0
                    local enemyZ = readInteger(enemyTablePtr + 0x1C, true) or 0

                    -- 計算X和Z的距離（水平距離）
                    local dx = enemyX - cachedPlayerX
                    local dz = enemyZ - cachedPlayerZ
                    local horizontalDist2 = dx*dx + dz*dz

                    -- 計算實際距離（開方）
                    local actualDistance = math.sqrt(horizontalDist2)

                    -- 檢查距離是否在範圍內
                    if actualDistance &gt; MIN_AIM_DISTANCE and actualDistance &lt; MAX_AIM_DISTANCE then
                      -- 計算Yaw角度
                      local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
                      if aimYaw &lt; 0 then
                        aimYaw = aimYaw + 360.0
                      end
                      aimYaw = aimYaw % 360.0

                      -- 檢查目標是否在FOV內
                      if isTargetInFOV(aimYaw, cachedPlayerYaw, actualFOVLimit) then
                        -- 計算Pitch角度
                        local dy = enemyY - cachedPlayerY
                        local aimPitch = -math.atan2(dy, actualDistance) * (180.0 / math.pi)

                        -- 限制Pitch範圍
                        if aimPitch &lt; -88.0 then aimPitch = -88.0 end
                        if aimPitch &gt; 88.0 then aimPitch = 88.0 end

                        -- 寫入瞄準角度
                        writeFloat(YAW_ADDRESS, aimYaw)
                        writeFloat(PITCH_ADDRESS, aimPitch)

                        foundValidEnemy = true
                      end
                    end
                  end
                end
              end

              -- 切換到下一個目標
              _aim_index = _aim_index + 1
              attempts = attempts + 1
            end
          end
        end
      end
    end

    sleep(1)
  end
end)

[DISABLE]
if LeftsuperLuaAutoClickForTriggerbot_thread then
  LeftsuperLuaAutoClickForTriggerbot_thread.terminate()
  LeftsuperLuaAutoClickForTriggerbot_thread.waitfor()
  LeftsuperLuaAutoClickForTriggerbot_thread.destroy()
  LeftsuperLuaAutoClickForTriggerbot_thread = nil
  _aim_index = nil
  _custom_fov_limit = nil
end
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>1807637701</ID>
      <Description>"逐個自瞄Lua(玩家訊息表Aimbot範圍90格)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$Lua}
if syntaxcheck then return end

[ENABLE]
-- 初始化索引為0（從第一個敵人開始）
if _aim_index == nil then
  _aim_index = 0
end

-- 初始化當前目標追蹤變數
if _current_target_ptr == nil then
  _current_target_ptr = nil        -- 儲存當前瞄準的目標指針
  _current_target_index = nil      -- 儲存當前瞄準的目標索引
  _current_target_last_hp = nil    -- 儲存上次檢查的目標血量
  _current_target_last_check = 0   -- 上次檢查目標的時間
end

-- 分開的Yaw和Pitch地址
local YAW_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+8"   -- Yaw角度地址
local PITCH_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+C"  -- Pitch角度地址

-- 距離配置（單位：遊戲單位）
local MIN_AIM_DISTANCE = 10   -- 最小瞄準距離
local MAX_AIM_DISTANCE = 9000  -- 最大瞄準距離

-- 目標檢查配置
local TARGET_CHECK_INTERVAL = 50  -- 檢查目標狀態的間隔（毫秒）

LeftsuperLuaAutoClickForTriggerbot_thread = createNativeThread(function (thread)
  thread.freeOnTerminate(false)
  thread.Name = 'Aimbot_thread'

  -- 緩存玩家資訊，減少重複讀取
  local cachedSelfFaction = nil
  local cachedPlayerX, cachedPlayerY, cachedPlayerZ = nil, nil, nil
  local cachedEnemyCount = 0
  local cachedEnemyListBase = nil
  local lastCacheUpdate = 0

  -- 函數：檢查目標是否仍然有效
  local function isTargetStillValid(targetPtr)
    if not targetPtr or targetPtr == 0 then
      return false
    end

    -- 檢查目標是否在列表中（通過讀取血量）
    local enemyHP = readFloat(targetPtr + 0x10) or 0.0
    return enemyHP &gt; 0.0
  end

  -- 函數：計算並瞄準目標
  local function aimAtTarget(targetPtr, playerX, playerY, playerZ)
    if not targetPtr or targetPtr == 0 then
      return false
    end

    -- 讀取目標位置
    local enemyX = readInteger(targetPtr + 0x14, true) or 0
    local enemyY = readInteger(targetPtr + 0x18, true) or 0
    local enemyZ = readInteger(targetPtr + 0x1C, true) or 0

    -- 計算X和Z的距離（水平距離）
    local dx = enemyX - playerX
    local dz = enemyZ - playerZ
    local horizontalDist2 = dx*dx + dz*dz
    local actualDistance = math.sqrt(horizontalDist2)

    -- 檢查距離是否在範圍內
    if actualDistance &gt; MIN_AIM_DISTANCE and actualDistance &lt; MAX_AIM_DISTANCE then
      -- 計算Yaw角度
      local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
      if aimYaw &lt; 0 then
        aimYaw = aimYaw + 360.0
      end
      aimYaw = aimYaw % 360.0

      -- 計算Pitch角度
      local dy = enemyY - playerY
      local aimPitch = -math.atan2(dy, actualDistance) * (180.0 / math.pi)

      -- 限制Pitch範圍
      if aimPitch &lt; -88.0 then aimPitch = -88.0 end
      if aimPitch &gt; 88.0 then aimPitch = 88.0 end

      -- 寫入瞄準角度
      writeFloat(YAW_ADDRESS, aimYaw)
      writeFloat(PITCH_ADDRESS, aimPitch)

      return true
    end

    return false
  end

  while not thread.Terminated do
    -- 獲取敵人列表基址
    local basePtr = readInteger("libiworld.dll+169B900")

    if basePtr and basePtr ~= 0 then
      basePtr = readInteger(basePtr + 0x78)
      if basePtr and basePtr ~= 0 then
        -- 計算玩家數量：ret = (address1 - address2) // 4
        local address1 = readInteger(basePtr + 0x78) or 0
        local address2 = readInteger(basePtr + 0x74) or 0
        local enemyCount = 0

        if address1 &gt; address2 then
          enemyCount = math.floor((address1 - address2) / 4)
        end

        -- 檢查是否有有效敵人
        if enemyCount and enemyCount &gt; 0 then
          -- 定期更新緩存（每10ms）
          local currentTime = getTickCount()
          if currentTime - lastCacheUpdate &gt; 10 then
            -- 獲取玩家自身陣營（緩存）
            local SelfCampPtr = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+15C")
            if SelfCampPtr and SelfCampPtr ~= 0 then
              cachedSelfFaction = readInteger(SelfCampPtr + 0x24) or 0
            else
              cachedSelfFaction = 0
            end

            -- 獲取玩家自身位置（緩存）
            local playerBase = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+68")
            if playerBase then
              cachedPlayerX = readInteger(playerBase + 0x298, true) or 0
              cachedPlayerY = readInteger(playerBase + 0x29C, true) or 0
              cachedPlayerZ = readInteger(playerBase + 0x2A0, true) or 0
            end

            -- 緩存敵人列表基址和數量
            cachedEnemyListBase = address2
            cachedEnemyCount = enemyCount

            lastCacheUpdate = currentTime
          end

          -- 檢查緩存是否有效
          if cachedEnemyListBase and cachedEnemyListBase ~= 0 and
             cachedPlayerX and cachedPlayerY and cachedPlayerZ and
             cachedEnemyCount &gt; 0 then

            -- 1. 如果當前有目標，先檢查目標是否仍然有效
            if _current_target_ptr and _current_target_ptr ~= 0 then
              -- 定期檢查目標狀態
              if currentTime - _current_target_last_check &gt; TARGET_CHECK_INTERVAL then
                if isTargetStillValid(_current_target_ptr) then
                  -- 目標仍然有效，繼續瞄準
                  local success = aimAtTarget(_current_target_ptr, cachedPlayerX, cachedPlayerY, cachedPlayerZ)
                  if success then
                    _current_target_last_check = currentTime
                  else
                    -- 瞄準失敗（可能距離太遠），尋找新目標
                    _current_target_ptr = nil
                    _current_target_index = nil
                  end
                else
                  -- 目標已死亡或無效，尋找新目標
                  _current_target_ptr = nil
                  _current_target_index = nil
                end
              else
                -- 未到檢查時間，繼續瞄準當前目標
                aimAtTarget(_current_target_ptr, cachedPlayerX, cachedPlayerY, cachedPlayerZ)
              end
            end

            -- 2. 如果沒有當前目標，尋找新目標
            if not _current_target_ptr or _current_target_ptr == 0 then
              local foundValidEnemy = false
              local attempts = 0

              while not foundValidEnemy and attempts &lt; cachedEnemyCount and not thread.Terminated do
                -- 確保索引在有效範圍內
                if _aim_index &gt;= cachedEnemyCount then
                  _aim_index = 0
                end

                -- 計算當前敵人類型指針地址
                local enemyTablePtr = readInteger(cachedEnemyListBase + _aim_index * 4)

                if enemyTablePtr and enemyTablePtr ~= 0 then
                  -- 讀取血量
                  local enemyHP = readFloat(enemyTablePtr + 0x10) or 100.0

                  -- 檢查血量是否有效
                  if enemyHP &gt; 0.0 then
                    -- 讀取陣營
                    local enemyFaction = readInteger(enemyTablePtr + 0x24) or 0

                    -- 陣營判斷
                    local shouldAim = false

                    if cachedSelfFaction == 0 then
                      shouldAim = true
                    elseif enemyFaction ~= cachedSelfFaction then
                      shouldAim = true
                    end

                    if shouldAim then
                      -- 嘗試瞄準這個目標
                      local success = aimAtTarget(enemyTablePtr, cachedPlayerX, cachedPlayerY, cachedPlayerZ)

                      if success then
                        -- 設置為當前目標
                        _current_target_ptr = enemyTablePtr
                        _current_target_index = _aim_index
                        _current_target_last_hp = enemyHP
                        _current_target_last_check = currentTime
                        foundValidEnemy = true

                        -- 移動到下一索引，以便下次尋找新目標時從下一個開始
                        _aim_index = _aim_index + 1
                        if _aim_index &gt;= cachedEnemyCount then
                          _aim_index = 0
                        end
                      end
                    end
                  end
                end

                -- 如果沒找到，切換到下一個目標
                if not foundValidEnemy then
                  _aim_index = _aim_index + 1
                  attempts = attempts + 1
                end
              end
            end
          end
        else
          -- 沒有敵人時重置目標
          _current_target_ptr = nil
          _current_target_index = nil
        end
      end
    else
      -- 基址無效時重置目標
      _current_target_ptr = nil
      _current_target_index = nil
    end

    sleep(1)
  end
end)

[DISABLE]
if LeftsuperLuaAutoClickForTriggerbot_thread then
  LeftsuperLuaAutoClickForTriggerbot_thread.terminate()
  LeftsuperLuaAutoClickForTriggerbot_thread.waitfor()
  LeftsuperLuaAutoClickForTriggerbot_thread.destroy()
  LeftsuperLuaAutoClickForTriggerbot_thread = nil
  _aim_index = nil
  _current_target_ptr = nil
  _current_target_index = nil
  _current_target_last_hp = nil
  _current_target_last_check = nil
end
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>1807637705</ID>
      <Description>"逐個Aimbot-Lua(玩家訊息表Aimbot範圍90格+FOV)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$Lua}
if syntaxcheck then return end

[ENABLE]
-- 初始化索引為0（從第一個敵人開始）
if _aim_index == nil then
  _aim_index = 0
end

-- 自定義自瞄角度設定（可以在這裡調整）
if _custom_aim_angle == nil then
  _custom_aim_angle = 0.0  -- 預設為0表示使用FOV（忽略高度/Y軸）
end

-- 初始化當前目標追蹤變數
if _current_target_ptr == nil then
  _current_target_ptr = nil        -- 儲存當前瞄準的目標指針
  _current_target_index = nil      -- 儲存當前瞄準的目標索引
  _current_target_last_hp = nil    -- 儲存上次檢查的目標血量
  _current_target_last_check = 0   -- 上次檢查目標的時間
end

-- 分開的Yaw和Pitch地址
local YAW_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+8"   -- Yaw角度地址
local PITCH_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+C"  -- Pitch角度地址
local FOV_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+B4"   -- FOV地址

-- 距離配置（單位：遊戲單位）
local MIN_AIM_DISTANCE = 10   -- 最小瞄準距離
local MAX_AIM_DISTANCE = 9000  -- 最大瞄準距離

-- 目標檢查配置
local TARGET_CHECK_INTERVAL = 50  -- 檢查目標狀態的間隔（毫秒）

LeftsuperLuaAutoClickForTriggerbot_thread = createNativeThread(function (thread)
  thread.freeOnTerminate(false)
  thread.Name = 'Aimbot_thread'

  -- 緩存玩家資訊，減少重複讀取
  local cachedSelfFaction = nil
  local cachedPlayerX, cachedPlayerY, cachedPlayerZ = nil, nil, nil
  local cachedPlayerYaw = nil  -- 只緩存玩家當前Yaw角度（忽略Pitch）
  local cachedCurrentFOV = nil  -- 緩存當前FOV
  local cachedEnemyCount = 0
  local cachedEnemyListBase = nil
  local lastCacheUpdate = 0

  -- 函數：計算兩個角度之間的最小差值（僅Yaw）
  local function yawAngleDifference(angle1, angle2)
    local diff = math.abs(angle1 - angle2) % 360
    return math.min(diff, 360 - diff)
  end

  -- 函數：檢查目標是否在FOV範圍內（僅Yaw，忽略高度）
  local function isTargetInFOV(targetYaw, playerYaw, fovAngle)
    if not playerYaw or not fovAngle then
      return true  -- 如果無法讀取玩家角度或FOV，則允許瞄準所有目標
    end

    -- 計算Yaw角度差
    local yawDiff = yawAngleDifference(targetYaw, playerYaw)

    -- 檢查是否在FOV角度範圍內（FOV/2作為視野半徑）
    return yawDiff &lt;= (fovAngle / 2)
  end

  -- 函數：根據自定義角度和FOV計算實際角度
  local function getActualAimAngle(currentFOV, customAngle)
    -- 如果自定義角度 &gt; 0，使用自定義角度
    if customAngle &gt; 0 then
      return customAngle
    else
      -- 否則使用遊戲的FOV
      return currentFOV
    end
  end

  -- 函數：檢查目標是否仍然有效
  local function isTargetStillValid(targetPtr)
    if not targetPtr or targetPtr == 0 then
      return false
    end

    -- 檢查目標是否在列表中（通過讀取血量）
    local enemyHP = readFloat(targetPtr + 0x10) or 0.0
    return enemyHP &gt; 0.0
  end

  -- 函數：計算並瞄準目標（包含FOV檢查，忽略高度）
  local function aimAtTarget(targetPtr, playerX, playerY, playerZ, playerYaw, aimAngle)
    if not targetPtr or targetPtr == 0 then
      return false
    end

    -- 讀取目標位置
    local enemyX = readInteger(targetPtr + 0x14, true) or 0
    local enemyY = readInteger(targetPtr + 0x18, true) or 0
    local enemyZ = readInteger(targetPtr + 0x1C, true) or 0

    -- 計算X和Z的距離（水平距離）
    local dx = enemyX - playerX
    local dz = enemyZ - playerZ
    local horizontalDist2 = dx*dx + dz*dz
    local actualDistance = math.sqrt(horizontalDist2)

    -- 檢查距離是否在範圍內
    if actualDistance &gt; MIN_AIM_DISTANCE and actualDistance &lt; MAX_AIM_DISTANCE then
      -- 計算Yaw角度
      local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
      if aimYaw &lt; 0 then
        aimYaw = aimYaw + 360.0
      end
      aimYaw = aimYaw % 360.0

      -- 計算Pitch角度（但忽略高度檢查）
      local dy = enemyY - playerY
      local aimPitch = -math.atan2(dy, actualDistance) * (180.0 / math.pi)

      -- 限制Pitch範圍
      if aimPitch &lt; -88.0 then aimPitch = -88.0 end
      if aimPitch &gt; 88.0 then aimPitch = 88.0 end

      -- 檢查目標是否在FOV範圍內（僅Yaw，忽略高度）
      if isTargetInFOV(aimYaw, playerYaw, aimAngle) then
        -- 寫入瞄準角度
        writeFloat(YAW_ADDRESS, aimYaw)
        writeFloat(PITCH_ADDRESS, aimPitch)
        return true
      end
    end

    return false
  end

  while not thread.Terminated do
    -- 獲取敵人列表基址
    local basePtr = readInteger("libiworld.dll+169B900")

    if basePtr and basePtr ~= 0 then
      basePtr = readInteger(basePtr + 0x78)
      if basePtr and basePtr ~= 0 then
        -- 計算玩家數量：ret = (address1 - address2) // 4
        local address1 = readInteger(basePtr + 0x78) or 0
        local address2 = readInteger(basePtr + 0x74) or 0
        local enemyCount = 0

        if address1 &gt; address2 then
          enemyCount = math.floor((address1 - address2) / 4)
        end

        -- 檢查是否有有效敵人
        if enemyCount and enemyCount &gt; 0 then
          -- 定期更新緩存（每10ms）
          local currentTime = getTickCount()
          if currentTime - lastCacheUpdate &gt; 10 then
            -- 獲取玩家自身陣營（緩存）
            local SelfCampPtr = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+15C")
            if SelfCampPtr and SelfCampPtr ~= 0 then
              cachedSelfFaction = readInteger(SelfCampPtr + 0x24) or 0
            else
              cachedSelfFaction = 0
            end

            -- 獲取玩家自身位置（緩存）
            local playerBase = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+68")
            if playerBase then
              cachedPlayerX = readInteger(playerBase + 0x298, true) or 0
              cachedPlayerY = readInteger(playerBase + 0x29C, true) or 0
              cachedPlayerZ = readInteger(playerBase + 0x2A0, true) or 0
            end

            -- 更新玩家當前Yaw角度（從遊戲內讀取，忽略Pitch）
            cachedPlayerYaw = readFloat(YAW_ADDRESS) or 0.0

            -- 更新當前FOV（動態讀取）
            cachedCurrentFOV = readFloat(FOV_ADDRESS) or 0.0

            -- 緩存敵人列表基址和數量
            cachedEnemyListBase = address2
            cachedEnemyCount = enemyCount

            lastCacheUpdate = currentTime
          end

          -- 檢查緩存是否有效
          if cachedEnemyListBase and cachedEnemyListBase ~= 0 and
             cachedPlayerX and cachedPlayerY and cachedPlayerZ and
             cachedEnemyCount &gt; 0 then

            -- 計算實際瞄準角度（根據自定義角度或FOV）
            local actualAimAngle = 0.0
            if cachedCurrentFOV and cachedCurrentFOV &gt; 0 then
              actualAimAngle = getActualAimAngle(cachedCurrentFOV, _custom_aim_angle)
            else
              -- 如果讀取不到FOV，使用自定義角度或預設60度
              actualAimAngle = _custom_aim_angle &gt; 0 and _custom_aim_angle or 60.0
            end

            -- 1. 如果當前有目標，先檢查目標是否仍然有效
            if _current_target_ptr and _current_target_ptr ~= 0 then
              -- 定期檢查目標狀態
              if currentTime - _current_target_last_check &gt; TARGET_CHECK_INTERVAL then
                if isTargetStillValid(_current_target_ptr) then
                  -- 目標仍然有效，繼續瞄準
                  local success = aimAtTarget(_current_target_ptr, cachedPlayerX, cachedPlayerY, cachedPlayerZ,
                                             cachedPlayerYaw, actualAimAngle)
                  if success then
                    _current_target_last_check = currentTime
                  else
                    -- 瞄準失敗（可能距離太遠或不在FOV內），尋找新目標
                    _current_target_ptr = nil
                    _current_target_index = nil
                  end
                else
                  -- 目標已死亡或無效，尋找新目標
                  _current_target_ptr = nil
                  _current_target_index = nil
                end
              else
                -- 未到檢查時間，繼續瞄準當前目標
                aimAtTarget(_current_target_ptr, cachedPlayerX, cachedPlayerY, cachedPlayerZ,
                           cachedPlayerYaw, actualAimAngle)
              end
            end

            -- 2. 如果沒有當前目標，尋找新目標
            if not _current_target_ptr or _current_target_ptr == 0 then
              local foundValidEnemy = false
              local attempts = 0

              while not foundValidEnemy and attempts &lt; cachedEnemyCount and not thread.Terminated do
                -- 確保索引在有效範圍內
                if _aim_index &gt;= cachedEnemyCount then
                  _aim_index = 0
                end

                -- 計算當前敵人類型指針地址
                local enemyTablePtr = readInteger(cachedEnemyListBase + _aim_index * 4)

                if enemyTablePtr and enemyTablePtr ~= 0 then
                  -- 讀取血量
                  local enemyHP = readFloat(enemyTablePtr + 0x10) or 100.0

                  -- 檢查血量是否有效
                  if enemyHP &gt; 0.0 then
                    -- 讀取陣營
                    local enemyFaction = readInteger(enemyTablePtr + 0x24) or 0

                    -- 陣營判斷
                    local shouldAim = false

                    if cachedSelfFaction == 0 then
                      shouldAim = true
                    elseif enemyFaction ~= cachedSelfFaction then
                      shouldAim = true
                    end

                    if shouldAim then
                      -- 嘗試瞄準這個目標（包含FOV檢查，忽略高度）
                      local success = aimAtTarget(enemyTablePtr, cachedPlayerX, cachedPlayerY, cachedPlayerZ,
                                                 cachedPlayerYaw, actualAimAngle)

                      if success then
                        -- 設置為當前目標
                        _current_target_ptr = enemyTablePtr
                        _current_target_index = _aim_index
                        _current_target_last_hp = enemyHP
                        _current_target_last_check = currentTime
                        foundValidEnemy = true

                        -- 移動到下一索引，以便下次尋找新目標時從下一個開始
                        _aim_index = _aim_index + 1
                        if _aim_index &gt;= cachedEnemyCount then
                          _aim_index = 0
                        end
                      end
                    end
                  end
                end

                -- 如果沒找到，切換到下一個目標
                if not foundValidEnemy then
                  _aim_index = _aim_index + 1
                  attempts = attempts + 1
                end
              end
            end
          end
        else
          -- 沒有敵人時重置目標
          _current_target_ptr = nil
          _current_target_index = nil
        end
      end
    else
      -- 基址無效時重置目標
      _current_target_ptr = nil
      _current_target_index = nil
    end

    sleep(1)
  end
end)

[DISABLE]
if LeftsuperLuaAutoClickForTriggerbot_thread then
  LeftsuperLuaAutoClickForTriggerbot_thread.terminate()
  LeftsuperLuaAutoClickForTriggerbot_thread.waitfor()
  LeftsuperLuaAutoClickForTriggerbot_thread.destroy()
  LeftsuperLuaAutoClickForTriggerbot_thread = nil
  _aim_index = nil
  _custom_aim_angle = nil
  _current_target_ptr = nil
  _current_target_index = nil
  _current_target_last_hp = nil
  _current_target_last_check = nil
end
</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
