<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="45">
  <CheatEntries>
    <CheatEntry>
      <ID>1807637582</ID>
      <Description>"暴力Aim-Lua(玩家實例表Aimbot)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$Lua}
if syntaxcheck then return end

[ENABLE]
if _aim_index == nil then
  _aim_index = 1
end

-- 分開的Yaw和Pitch地址
local YAW_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+8"   -- Yaw角度地址
local PITCH_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+C"  -- Pitch角度地址

LeftsuperLuaAutoClickForTriggerbot_thread = createNativeThread(function (thread)
  thread.freeOnTerminate(false)
  thread.Name = 'Aimbot_thread'

  -- 緩存玩家信息，減少重複讀取
  local cachedSelfFaction = nil
  local cachedPlayerX, cachedPlayerY, cachedPlayerZ = nil, nil, nil
  local lastCacheUpdate = 0

  -- 緩存敵人列表，減少讀取
  local cachedPlayerList = nil
  local cachedEnemyCount = nil

  while not thread.Terminated do
    -- 獲取敵人數量（緩存優化）
    local enemyCount = readInteger("[libSandboxEngine.dll+1863938]+4")

    -- 檢查是否有有效敵人
    if enemyCount and enemyCount &gt; 1 then
      -- 定期更新緩存（每100ms）
      local currentTime = getTickCount()
      if currentTime - lastCacheUpdate &gt; 10 then
        -- 更新玩家陣營緩存
        local SelfCampPtr = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+15C")
        if SelfCampPtr and SelfCampPtr ~= 0 then
          cachedSelfFaction = readInteger(SelfCampPtr + 0x24) or 0
        else
          cachedSelfFaction = 0
        end

        -- 更新玩家位置緩存（直接讀取有符號整數）
        local playerBase = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+68")
        if playerBase then
          cachedPlayerX = readInteger(playerBase + 0x298, true) or 0
          cachedPlayerY = readInteger(playerBase + 0x29C, true) or 0
          cachedPlayerZ = readInteger(playerBase + 0x2A0, true) or 0
        end

        -- 更新敵人列表緩存
        cachedPlayerList = readInteger("[[[[[libSandboxEngine.dll+19A6B20]+1C4]+4]+14]+158]+18")
        cachedEnemyCount = enemyCount

        lastCacheUpdate = currentTime
      end

      -- 檢查緩存是否有效
      if cachedPlayerList and cachedPlayerList ~= 0 then
        local foundValidEnemy = false

        -- 嘗試尋找有效敵人（最多嘗試5個）
        local attempts = 0
        local maxCount = readInteger("[libSandboxEngine.dll+1863938]+4")
        local maxAttempts = math.min(enemyCount, maxCount)

        while not foundValidEnemy and attempts &lt; maxAttempts and not thread.Terminated do
          local enemyInstance = readInteger(cachedPlayerList + _aim_index * 4)

          if enemyInstance and enemyInstance ~= 0 then
            -- 血量判斷
            local EnemyHPPtr = readInteger(enemyInstance + 0xC8)
            local EnemyHP = 100.0

            if EnemyHPPtr and EnemyHPPtr ~= 0 then
              EnemyHP = readFloat(EnemyHPPtr + 0x24) or 100.0
            end

            if EnemyHP &gt; 0.00 then
              -- 陣營判斷
              local EnemyCampPtr = readInteger(enemyInstance + 0x15C)
              local EnemyFaction = 0

              if EnemyCampPtr and EnemyCampPtr ~= 0 then
                EnemyFaction = readInteger(EnemyCampPtr + 0x24) or 0
              end

              local shouldAim = false

              if cachedSelfFaction == 0 then
                shouldAim = true
              elseif EnemyFaction ~= cachedSelfFaction then
                shouldAim = true
              end

              -- 角度計算
              if shouldAim then
                local locationPtr = readInteger(enemyInstance + 0x68)

                if locationPtr and locationPtr ~= 0 then
                  -- 直接讀取有符號整數
                  local enemyX = readInteger(locationPtr + 0x298, true) or 0
                  local enemyY = readInteger(locationPtr + 0x29C, true) or 0
                  local enemyZ = readInteger(locationPtr + 0x2A0, true) or 0

                  -- 使用緩存的玩家位置
                  if cachedPlayerX and cachedPlayerY and cachedPlayerZ then
                    -- 計算相對位置
                    local dx = enemyX - cachedPlayerX
                    local dz = enemyZ - cachedPlayerZ
                    local dy = enemyY - cachedPlayerY

                    -- 計算水平距離平方（避免開方運算）
                    local horizontalDist2 = dx*dx + dz*dz

                    -- 設置最小距離閾值（避免零距離）
                    if horizontalDist2 &gt; 1 then
                      local horizontalDist = math.sqrt(horizontalDist2)

                      -- 快速計算角度
                      local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
                      if aimYaw &lt; 0 then
                        aimYaw = aimYaw + 360.0
                      end
                      aimYaw = aimYaw % 360.0

                      local aimPitch = -math.atan2(dy, horizontalDist) * (180.0 / math.pi)

                      -- 限制Pitch範圍
                      if aimPitch &lt; -88.0 then aimPitch = -88.0 end
                      if aimPitch &gt; 88.0 then aimPitch = 88.0 end

                      -- 直接寫入角度
                      writeFloat(YAW_ADDRESS, aimYaw)
                      writeFloat(PITCH_ADDRESS, aimPitch)

                      foundValidEnemy = true
                    end
                  end
                end
              end
            end
          end

          -- 切換到下一個目標
          _aim_index = _aim_index + 1
          if _aim_index &gt;= cachedEnemyCount then
            _aim_index = 1
          end

          attempts = attempts + 1
        end
      end
    end

   sleep(1)
  end
end)

[DISABLE]
if LeftsuperLuaAutoClickForTriggerbot_thread then
  LeftsuperLuaAutoClickForTriggerbot_thread.terminate()
  LeftsuperLuaAutoClickForTriggerbot_thread.waitfor()
  LeftsuperLuaAutoClickForTriggerbot_thread.destroy()
  LeftsuperLuaAutoClickForTriggerbot_thread = nil
  _aim_index = nil
end
</AssemblerScript>
      <Hotkeys>
        <Hotkey Active="0">
          <Action>Toggle Activation</Action>
          <Keys>
            <Key>17</Key>
            <Key>81</Key>
          </Keys>
          <ID>0</ID>
        </Hotkey>
      </Hotkeys>
    </CheatEntry>
    <CheatEntry>
      <ID>1807637700</ID>
      <Description>"逐個Aim-Lua(玩家實例表Aimbot)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$Lua}
if syntaxcheck then return end

[ENABLE]
if _aim_index == nil then
  _aim_index = 1
end

-- 添加當前目標追蹤變數
if _current_target == nil then
  _current_target = nil  -- 儲存當前瞄準的目標地址
  _current_target_index = nil  -- 儲存當前瞄準的目標索引
  _current_target_valid = false  -- 標記當前目標是否有效
end

-- 分開的Yaw和Pitch地址
local YAW_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+8"   -- Yaw角度地址
local PITCH_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+C"  -- Pitch角度地址

LeftsuperLuaAutoClickForTriggerbot_thread = createNativeThread(function (thread)
  thread.freeOnTerminate(false)
  thread.Name = 'Aimbot_thread'

  -- 緩存玩家資訊，減少重複讀取
  local cachedSelfFaction = nil
  local cachedPlayerX, cachedPlayerY, cachedPlayerZ = nil, nil, nil
  local lastCacheUpdate = 0

  -- 緩存敵人列表，減少讀取
  local cachedPlayerList = nil
  local cachedEnemyCount = nil

  while not thread.Terminated do
    -- 獲取敵人數量（緩存優化）
    local enemyCount = readInteger("[libSandboxEngine.dll+1863938]+4")

    -- 檢查是否有有效敵人
    if enemyCount and enemyCount &gt; 1 then
      -- 定期更新緩存（每100ms）
      local currentTime = getTickCount()
      if currentTime - lastCacheUpdate &gt; 10 then
        -- 更新玩家陣營緩存
        local SelfCampPtr = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+15C")
        if SelfCampPtr and SelfCampPtr ~= 0 then
          cachedSelfFaction = readInteger(SelfCampPtr + 0x24) or 0
        else
          cachedSelfFaction = 0
        end

        -- 更新玩家位置緩存（直接讀取有符號整數）
        local playerBase = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+68")
        if playerBase then
          cachedPlayerX = readInteger(playerBase + 0x298, true) or 0
          cachedPlayerY = readInteger(playerBase + 0x29C, true) or 0
          cachedPlayerZ = readInteger(playerBase + 0x2A0, true) or 0
        end

        -- 更新敵人列表緩存
        cachedPlayerList = readInteger("[[[[[libSandboxEngine.dll+19A6B20]+1C4]+4]+14]+158]+18")
        cachedEnemyCount = enemyCount

        lastCacheUpdate = currentTime
      end

      -- 檢查緩存是否有效
      if cachedPlayerList and cachedPlayerList ~= 0 then
        -- 1. 先檢查當前目標是否仍然有效
        local needNewTarget = true

        if _current_target and _current_target ~= 0 and _current_target_index then
          -- 重新讀取當前目標的血量
          local EnemyHPPtr = readInteger(_current_target + 0xC8)
          local EnemyHP = 100.0

          if EnemyHPPtr and EnemyHPPtr ~= 0 then
            EnemyHP = readFloat(EnemyHPPtr + 0x24) or 100.0
          end

          -- 檢查目標是否還活著且有效
          if EnemyHP &gt; 0.00 then
            -- 檢查陣營是否仍然有效
            local EnemyCampPtr = readInteger(_current_target + 0x15C)
            local EnemyFaction = 0

            if EnemyCampPtr and EnemyCampPtr ~= 0 then
              EnemyFaction = readInteger(EnemyCampPtr + 0x24) or 0
            end

            local shouldAim = false
            if cachedSelfFaction == 0 then
              shouldAim = true
            elseif EnemyFaction ~= cachedSelfFaction then
              shouldAim = true
            end

            if shouldAim then
              -- 檢查目標位置是否有效
              local locationPtr = readInteger(_current_target + 0x68)
              if locationPtr and locationPtr ~= 0 then
                needNewTarget = false
                _current_target_valid = true

                -- 繼續瞄準當前目標
                local enemyX = readInteger(locationPtr + 0x298, true) or 0
                local enemyY = readInteger(locationPtr + 0x29C, true) or 0
                local enemyZ = readInteger(locationPtr + 0x2A0, true) or 0

                -- 使用緩存的玩家位置
                if cachedPlayerX and cachedPlayerY and cachedPlayerZ then
                  -- 計算相對位置
                  local dx = enemyX - cachedPlayerX
                  local dz = enemyZ - cachedPlayerZ
                  local dy = enemyY - cachedPlayerY

                  -- 計算水平距離平方（避免開方運算）
                  local horizontalDist2 = dx*dx + dz*dz

                  -- 設置最小距離閾值（避免零距離）
                  if horizontalDist2 &gt; 1 then
                    local horizontalDist = math.sqrt(horizontalDist2)

                    -- 快速計算角度
                    local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
                    if aimYaw &lt; 0 then
                      aimYaw = aimYaw + 360.0
                    end
                    aimYaw = aimYaw % 360.0

                    local aimPitch = -math.atan2(dy, horizontalDist) * (180.0 / math.pi)

                    -- 限制Pitch範圍
                    if aimPitch &lt; -88.0 then aimPitch = -88.0 end
                    if aimPitch &gt; 88.0 then aimPitch = 88.0 end

                    -- 直接寫入角度
                    writeFloat(YAW_ADDRESS, aimYaw)
                    writeFloat(PITCH_ADDRESS, aimPitch)
                  end
                end
              end
            end
          end
        end

        -- 2. 如果需要新目標，尋找下一個有效目標
        if needNewTarget then
          _current_target = nil
          _current_target_index = nil
          _current_target_valid = false

          local foundValidEnemy = false
          local attempts = 0
          local maxCount = readInteger("[libSandboxEngine.dll+1863938]+4")
          local maxAttempts = math.min(enemyCount, maxCount)

          while not foundValidEnemy and attempts &lt; maxAttempts and not thread.Terminated do
            local enemyInstance = readInteger(cachedPlayerList + _aim_index * 4)

            if enemyInstance and enemyInstance ~= 0 then
              -- 血量判斷
              local EnemyHPPtr = readInteger(enemyInstance + 0xC8)
              local EnemyHP = 100.0

              if EnemyHPPtr and EnemyHPPtr ~= 0 then
                EnemyHP = readFloat(EnemyHPPtr + 0x24) or 100.0
              end

              if EnemyHP &gt; 0.00 then
                -- 陣營判斷
                local EnemyCampPtr = readInteger(enemyInstance + 0x15C)
                local EnemyFaction = 0

                if EnemyCampPtr and EnemyCampPtr ~= 0 then
                  EnemyFaction = readInteger(EnemyCampPtr + 0x24) or 0
                end

                local shouldAim = false

                if cachedSelfFaction == 0 then
                  shouldAim = true
                elseif EnemyFaction ~= cachedSelfFaction then
                  shouldAim = true
                end

                -- 角度計算
                if shouldAim then
                  local locationPtr = readInteger(enemyInstance + 0x68)

                  if locationPtr and locationPtr ~= 0 then
                    -- 直接讀取有符號整數
                    local enemyX = readInteger(locationPtr + 0x298, true) or 0
                    local enemyY = readInteger(locationPtr + 0x29C, true) or 0
                    local enemyZ = readInteger(locationPtr + 0x2A0, true) or 0

                    -- 使用緩存的玩家位置
                    if cachedPlayerX and cachedPlayerY and cachedPlayerZ then
                      -- 計算相對位置
                      local dx = enemyX - cachedPlayerX
                      local dz = enemyZ - cachedPlayerZ
                      local dy = enemyY - cachedPlayerY

                      -- 計算水平距離平方（避免開方運算）
                      local horizontalDist2 = dx*dx + dz*dz

                      -- 設置最小距離閾值（避免零距離）
                      if horizontalDist2 &gt; 1 then
                        local horizontalDist = math.sqrt(horizontalDist2)

                        -- 快速計算角度
                        local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
                        if aimYaw &lt; 0 then
                          aimYaw = aimYaw + 360.0
                        end
                        aimYaw = aimYaw % 360.0

                        local aimPitch = -math.atan2(dy, horizontalDist) * (180.0 / math.pi)

                        -- 限制Pitch範圍
                        if aimPitch &lt; -88.0 then aimPitch = -88.0 end
                        if aimPitch &gt; 88.0 then aimPitch = 88.0 end

                        -- 直接寫入角度
                        writeFloat(YAW_ADDRESS, aimYaw)
                        writeFloat(PITCH_ADDRESS, aimPitch)

                        -- 設置為當前目標
                        _current_target = enemyInstance
                        _current_target_index = _aim_index
                        _current_target_valid = true
                        foundValidEnemy = true
                      end
                    end
                  end
                end
              end
            end

            -- 切換到下一個目標
            _aim_index = _aim_index + 1
            if _aim_index &gt;= cachedEnemyCount then
              _aim_index = 1
            end

            attempts = attempts + 1
          end
        end
      end
    else
      -- 沒有敵人時重置目標
      _current_target = nil
      _current_target_index = nil
      _current_target_valid = false
    end

   sleep(1)
  end
end)

[DISABLE]
if LeftsuperLuaAutoClickForTriggerbot_thread then
  LeftsuperLuaAutoClickForTriggerbot_thread.terminate()
  LeftsuperLuaAutoClickForTriggerbot_thread.waitfor()
  LeftsuperLuaAutoClickForTriggerbot_thread.destroy()
  LeftsuperLuaAutoClickForTriggerbot_thread = nil
  _aim_index = nil
  _current_target = nil
  _current_target_index = nil
  _current_target_valid = nil
end
</AssemblerScript>
      <Hotkeys>
        <Hotkey>
          <Action>Toggle Activation</Action>
          <Keys>
            <Key>17</Key>
            <Key>81</Key>
          </Keys>
          <ID>0</ID>
        </Hotkey>
      </Hotkeys>
    </CheatEntry>
    <CheatEntry>
      <ID>1807637699</ID>
      <Description>"暴力Aimbot-Lua(玩家訊息表Aimbot範圍90格)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$Lua}
if syntaxcheck then return end

[ENABLE]
-- 初始化索引為0（從第一個敵人開始）
if _aim_index == nil then
  _aim_index = 0
end

-- 分開的Yaw和Pitch地址
local YAW_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+8"   -- Yaw角度地址
local PITCH_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+C"  -- Pitch角度地址

-- 距離配置（單位：遊戲單位）
local MIN_AIM_DISTANCE = 10   -- 最小瞄準距離
local MAX_AIM_DISTANCE = 9000  -- 最大瞄準距離

LeftsuperLuaAutoClickForTriggerbot_thread = createNativeThread(function (thread)
  thread.freeOnTerminate(false)
  thread.Name = 'Aimbot_thread'

  -- 緩存玩家信息，減少重複讀取
  local cachedSelfFaction = nil
  local cachedPlayerX, cachedPlayerY, cachedPlayerZ = nil, nil, nil
  local cachedEnemyCount = 0
  local cachedEnemyListBase = nil
  local lastCacheUpdate = 0

  while not thread.Terminated do
    -- 獲取敵人列表基址
    local basePtr = readInteger("libiworld.dll+169B900")

    if basePtr and basePtr ~= 0 then
      basePtr = readInteger(basePtr + 0x78)
      if basePtr and basePtr ~= 0 then
        -- 計算玩家數量：ret = (address1 - address2) // 4
        local address1 = readInteger(basePtr + 0x78) or 0
        local address2 = readInteger(basePtr + 0x74) or 0
        local enemyCount = 0

        if address1 &gt; address2 then
          enemyCount = math.floor((address1 - address2) / 4)
        end

        -- 檢查是否有有效敵人
        if enemyCount and enemyCount &gt; 0 then
          -- 定期更新緩存（每10ms）
          local currentTime = getTickCount()
          if currentTime - lastCacheUpdate &gt; 10 then
            -- 獲取玩家自身陣營（緩存）
            local SelfCampPtr = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+15C")
            if SelfCampPtr and SelfCampPtr ~= 0 then
              cachedSelfFaction = readInteger(SelfCampPtr + 0x24) or 0
            else
              cachedSelfFaction = 0
            end

            -- 獲取玩家自身位置（緩存）
            local playerBase = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+68")
            if playerBase then
              cachedPlayerX = readInteger(playerBase + 0x298, true) or 0
              cachedPlayerY = readInteger(playerBase + 0x29C, true) or 0
              cachedPlayerZ = readInteger(playerBase + 0x2A0, true) or 0
            end

            -- 緩存敵人列表基址和數量
            cachedEnemyListBase = address2
            cachedEnemyCount = enemyCount

            lastCacheUpdate = currentTime
          end

          -- 檢查緩存是否有效
          if cachedEnemyListBase and cachedEnemyListBase ~= 0 and
             cachedPlayerX and cachedPlayerY and cachedPlayerZ and
             cachedEnemyCount &gt; 0 then

            local foundValidEnemy = false
            local attempts = 0

            while not foundValidEnemy and attempts &lt; cachedEnemyCount and not thread.Terminated do
              -- 確保索引在有效範圍內
              if _aim_index &gt;= cachedEnemyCount then
                _aim_index = 0
              end

              -- 計算當前敵人地址
              local enemyTablePtr = readInteger(cachedEnemyListBase + _aim_index * 4)

              if enemyTablePtr and enemyTablePtr ~= 0 then
                -- 讀取血量
                local enemyHP = readFloat(enemyTablePtr + 0x10) or 100.0

                -- 檢查血量是否有效
                if enemyHP &gt; 0.0 then
                  -- 讀取陣營
                  local enemyFaction = readInteger(enemyTablePtr + 0x24) or 0

                  -- 陣營判斷
                  local shouldAim = false

                  if cachedSelfFaction == 0 then
                    shouldAim = true
                  elseif enemyFaction ~= cachedSelfFaction then
                    shouldAim = true
                  end

                  if shouldAim then
                    -- 讀取敵人位置
                    local enemyX = readInteger(enemyTablePtr + 0x14, true) or 0
                    local enemyY = readInteger(enemyTablePtr + 0x18, true) or 0
                    local enemyZ = readInteger(enemyTablePtr + 0x1C, true) or 0

                    -- 計算X和Z的距離（水平距離）
                    local dx = enemyX - cachedPlayerX
                    local dz = enemyZ - cachedPlayerZ
                    local horizontalDist2 = dx*dx + dz*dz

                    -- 計算實際距離（開方）
                    local actualDistance = math.sqrt(horizontalDist2)

                    -- 只用一個IF判斷距離是否在範圍內
                    if actualDistance &gt; MIN_AIM_DISTANCE and actualDistance &lt; MAX_AIM_DISTANCE then
                      -- 計算Yaw角度
                      local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
                      if aimYaw &lt; 0 then
                        aimYaw = aimYaw + 360.0
                      end
                      aimYaw = aimYaw % 360.0

                      -- 計算Pitch角度
                      local dy = enemyY - cachedPlayerY
                      local aimPitch = -math.atan2(dy, actualDistance) * (180.0 / math.pi)

                      -- 限制Pitch範圍
                      if aimPitch &lt; -88.0 then aimPitch = -88.0 end
                      if aimPitch &gt; 88.0 then aimPitch = 88.0 end

                      -- 寫入瞄準角度
                      writeFloat(YAW_ADDRESS, aimYaw)
                      writeFloat(PITCH_ADDRESS, aimPitch)

                      foundValidEnemy = true
                    end
                  end
                end
              end

              -- 切換到下一個目標
              _aim_index = _aim_index + 1
              attempts = attempts + 1
            end
          end
        end
      end
    end

    sleep(1)
  end
end)

[DISABLE]
if LeftsuperLuaAutoClickForTriggerbot_thread then
  LeftsuperLuaAutoClickForTriggerbot_thread.terminate()
  LeftsuperLuaAutoClickForTriggerbot_thread.waitfor()
  LeftsuperLuaAutoClickForTriggerbot_thread.destroy()
  LeftsuperLuaAutoClickForTriggerbot_thread = nil
  _aim_index = nil
end
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>1807637701</ID>
      <Description>"逐個Aimbot-Lua(玩家訊息表Aimbot範圍90格)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$Lua}
if syntaxcheck then return end

[ENABLE]
-- 初始化索引為0（從第一個敵人開始）
if _aim_index == nil then
  _aim_index = 0
end

-- 初始化當前目標追蹤變數
if _current_target_ptr == nil then
  _current_target_ptr = nil        -- 儲存當前瞄準的目標指針
  _current_target_index = nil      -- 儲存當前瞄準的目標索引
  _current_target_last_hp = nil    -- 儲存上次檢查的目標血量
  _current_target_last_check = 0   -- 上次檢查目標的時間
end

-- 分開的Yaw和Pitch地址
local YAW_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+8"   -- Yaw角度地址
local PITCH_ADDRESS = "[[libSandboxEngine.dll+1868D10]+28]+C"  -- Pitch角度地址

-- 距離配置（單位：遊戲單位）
local MIN_AIM_DISTANCE = 10   -- 最小瞄準距離
local MAX_AIM_DISTANCE = 9000  -- 最大瞄準距離

-- 目標檢查配置
local TARGET_CHECK_INTERVAL = 50  -- 檢查目標狀態的間隔（毫秒）

LeftsuperLuaAutoClickForTriggerbot_thread = createNativeThread(function (thread)
  thread.freeOnTerminate(false)
  thread.Name = 'Aimbot_thread'

  -- 緩存玩家資訊，減少重複讀取
  local cachedSelfFaction = nil
  local cachedPlayerX, cachedPlayerY, cachedPlayerZ = nil, nil, nil
  local cachedEnemyCount = 0
  local cachedEnemyListBase = nil
  local lastCacheUpdate = 0

  -- 函數：檢查目標是否仍然有效
  local function isTargetStillValid(targetPtr)
    if not targetPtr or targetPtr == 0 then
      return false
    end

    -- 檢查目標是否在列表中（通過讀取血量）
    local enemyHP = readFloat(targetPtr + 0x10) or 0.0
    return enemyHP &gt; 0.0
  end

  -- 函數：計算並瞄準目標
  local function aimAtTarget(targetPtr, playerX, playerY, playerZ)
    if not targetPtr or targetPtr == 0 then
      return false
    end

    -- 讀取目標位置
    local enemyX = readInteger(targetPtr + 0x14, true) or 0
    local enemyY = readInteger(targetPtr + 0x18, true) or 0
    local enemyZ = readInteger(targetPtr + 0x1C, true) or 0

    -- 計算X和Z的距離（水平距離）
    local dx = enemyX - playerX
    local dz = enemyZ - playerZ
    local horizontalDist2 = dx*dx + dz*dz
    local actualDistance = math.sqrt(horizontalDist2)

    -- 檢查距離是否在範圍內
    if actualDistance &gt; MIN_AIM_DISTANCE and actualDistance &lt; MAX_AIM_DISTANCE then
      -- 計算Yaw角度
      local aimYaw = math.atan2(dx, dz) * (180.0 / math.pi)
      if aimYaw &lt; 0 then
        aimYaw = aimYaw + 360.0
      end
      aimYaw = aimYaw % 360.0

      -- 計算Pitch角度
      local dy = enemyY - playerY
      local aimPitch = -math.atan2(dy, actualDistance) * (180.0 / math.pi)

      -- 限制Pitch範圍
      if aimPitch &lt; -88.0 then aimPitch = -88.0 end
      if aimPitch &gt; 88.0 then aimPitch = 88.0 end

      -- 寫入瞄準角度
      writeFloat(YAW_ADDRESS, aimYaw)
      writeFloat(PITCH_ADDRESS, aimPitch)

      return true
    end

    return false
  end

  while not thread.Terminated do
    -- 獲取敵人列表基址
    local basePtr = readInteger("libiworld.dll+169B900")

    if basePtr and basePtr ~= 0 then
      basePtr = readInteger(basePtr + 0x78)
      if basePtr and basePtr ~= 0 then
        -- 計算玩家數量：ret = (address1 - address2) // 4
        local address1 = readInteger(basePtr + 0x78) or 0
        local address2 = readInteger(basePtr + 0x74) or 0
        local enemyCount = 0

        if address1 &gt; address2 then
          enemyCount = math.floor((address1 - address2) / 4)
        end

        -- 檢查是否有有效敵人
        if enemyCount and enemyCount &gt; 0 then
          -- 定期更新緩存（每10ms）
          local currentTime = getTickCount()
          if currentTime - lastCacheUpdate &gt; 10 then
            -- 獲取玩家自身陣營（緩存）
            local SelfCampPtr = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+15C")
            if SelfCampPtr and SelfCampPtr ~= 0 then
              cachedSelfFaction = readInteger(SelfCampPtr + 0x24) or 0
            else
              cachedSelfFaction = 0
            end

            -- 獲取玩家自身位置（緩存）
            local playerBase = readInteger("[[libSandboxGame.dll+34BB8FC]+15C]+68")
            if playerBase then
              cachedPlayerX = readInteger(playerBase + 0x298, true) or 0
              cachedPlayerY = readInteger(playerBase + 0x29C, true) or 0
              cachedPlayerZ = readInteger(playerBase + 0x2A0, true) or 0
            end

            -- 緩存敵人列表基址和數量
            cachedEnemyListBase = address2
            cachedEnemyCount = enemyCount

            lastCacheUpdate = currentTime
          end

          -- 檢查緩存是否有效
          if cachedEnemyListBase and cachedEnemyListBase ~= 0 and
             cachedPlayerX and cachedPlayerY and cachedPlayerZ and
             cachedEnemyCount &gt; 0 then

            -- 1. 如果當前有目標，先檢查目標是否仍然有效
            if _current_target_ptr and _current_target_ptr ~= 0 then
              -- 定期檢查目標狀態
              if currentTime - _current_target_last_check &gt; TARGET_CHECK_INTERVAL then
                if isTargetStillValid(_current_target_ptr) then
                  -- 目標仍然有效，繼續瞄準
                  local success = aimAtTarget(_current_target_ptr, cachedPlayerX, cachedPlayerY, cachedPlayerZ)
                  if success then
                    _current_target_last_check = currentTime
                  else
                    -- 瞄準失敗（可能距離太遠），尋找新目標
                    _current_target_ptr = nil
                    _current_target_index = nil
                  end
                else
                  -- 目標已死亡或無效，尋找新目標
                  _current_target_ptr = nil
                  _current_target_index = nil
                end
              else
                -- 未到檢查時間，繼續瞄準當前目標
                aimAtTarget(_current_target_ptr, cachedPlayerX, cachedPlayerY, cachedPlayerZ)
              end
            end

            -- 2. 如果沒有當前目標，尋找新目標
            if not _current_target_ptr or _current_target_ptr == 0 then
              local foundValidEnemy = false
              local attempts = 0

              while not foundValidEnemy and attempts &lt; cachedEnemyCount and not thread.Terminated do
                -- 確保索引在有效範圍內
                if _aim_index &gt;= cachedEnemyCount then
                  _aim_index = 0
                end

                -- 計算當前敵人類型指針地址
                local enemyTablePtr = readInteger(cachedEnemyListBase + _aim_index * 4)

                if enemyTablePtr and enemyTablePtr ~= 0 then
                  -- 讀取血量
                  local enemyHP = readFloat(enemyTablePtr + 0x10) or 100.0

                  -- 檢查血量是否有效
                  if enemyHP &gt; 0.0 then
                    -- 讀取陣營
                    local enemyFaction = readInteger(enemyTablePtr + 0x24) or 0

                    -- 陣營判斷
                    local shouldAim = false

                    if cachedSelfFaction == 0 then
                      shouldAim = true
                    elseif enemyFaction ~= cachedSelfFaction then
                      shouldAim = true
                    end

                    if shouldAim then
                      -- 嘗試瞄準這個目標
                      local success = aimAtTarget(enemyTablePtr, cachedPlayerX, cachedPlayerY, cachedPlayerZ)

                      if success then
                        -- 設置為當前目標
                        _current_target_ptr = enemyTablePtr
                        _current_target_index = _aim_index
                        _current_target_last_hp = enemyHP
                        _current_target_last_check = currentTime
                        foundValidEnemy = true

                        -- 移動到下一索引，以便下次尋找新目標時從下一個開始
                        _aim_index = _aim_index + 1
                        if _aim_index &gt;= cachedEnemyCount then
                          _aim_index = 0
                        end
                      end
                    end
                  end
                end

                -- 如果沒找到，切換到下一個目標
                if not foundValidEnemy then
                  _aim_index = _aim_index + 1
                  attempts = attempts + 1
                end
              end
            end
          end
        else
          -- 沒有敵人時重置目標
          _current_target_ptr = nil
          _current_target_index = nil
        end
      end
    else
      -- 基址無效時重置目標
      _current_target_ptr = nil
      _current_target_index = nil
    end

    sleep(1)
  end
end)

[DISABLE]
if LeftsuperLuaAutoClickForTriggerbot_thread then
  LeftsuperLuaAutoClickForTriggerbot_thread.terminate()
  LeftsuperLuaAutoClickForTriggerbot_thread.waitfor()
  LeftsuperLuaAutoClickForTriggerbot_thread.destroy()
  LeftsuperLuaAutoClickForTriggerbot_thread = nil
  _aim_index = nil
  _current_target_ptr = nil
  _current_target_index = nil
  _current_target_last_hp = nil
  _current_target_last_check = nil
end
</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
